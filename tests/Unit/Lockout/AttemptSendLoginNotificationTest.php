<?php

use Beliven\Lockout\Lockout;
use Beliven\Lockout\Notifications\AccountLogged;
use Beliven\Lockout\Tests\Fixtures\User;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Notification;
use Illuminate\Support\Facades\Schema;

describe('Lockout::attemptSendLoginNotification', function () {
    beforeEach(function () {
        // Ensure notifications are faked for assertions
        Notification::fake();

        // Default: ensure auth provider resolves to fixture when needed
        config()->set('auth.providers.users.model', \Beliven\Lockout\Tests\Fixtures\User::class);
    });

    afterEach(function () {
        try {
            Schema::dropIfExists('users');
        } catch (\Throwable $_) {
            // ignore
        }

        config()->set('auth.providers.users.model', null);
        // Reset feature toggle to default to avoid leaking state
        config()->set('lockout.lock_on_login', false);
    });

    it('is a no-op when lock_on_login is disabled', function () {
        // Ensure feature disabled
        config()->set('lockout.lock_on_login', false);

        // Create a lightweight model that has an identifier but is not persisted
        $model = new class extends \Beliven\Lockout\Tests\Support\LockableModelStub
        {
            public $email = 'foo@example.test';
        };

        $service = app(Lockout::class);

        // Should not send any notifications
        $service->attemptSendLoginNotification($model, (object) ['ip' => '127.0.0.1']);

        Notification::assertNothingSent();
    });

    it('is a no-op when the provided model does not implement notify()', function () {
        // Enable feature so the code path is exercised
        config()->set('lockout.lock_on_login', true);

        // Build a simple LockableModelStub instance without notify()
        $model = new class extends \Beliven\Lockout\Tests\Support\LockableModelStub
        {
            public $email = 'nonotify@example.test';
            // intentionally no notify() method
        };

        $service = app(Lockout::class);

        // Should not throw and should not send any notifications
        $service->attemptSendLoginNotification($model, (object) ['ip' => '127.0.0.1']);

        Notification::assertNothingSent();
    });

    it('sends AccountLogged notification when feature enabled and model is notifiable', function () {
        $email = 'logged@example.test';

        // Enable feature
        config()->set('lockout.lock_on_login', true);

        // Create users table and seed a notifiable user
        Schema::dropIfExists('users');
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('email')->unique();
            $table->string('password')->nullable();
            $table->timestamps();
        });

        config()->set('auth.providers.users.model', \Beliven\Lockout\Tests\Fixtures\User::class);

        User::query()->create([
            'email'    => $email,
            'password' => 'secret',
        ]);

        $user = User::query()->where('email', $email)->first();
        expect($user)->not->toBeNull();

        $service = app(Lockout::class);

        // Call the method under test with the persisted model
        $service->attemptSendLoginNotification($user, (object) ['ip' => '127.0.0.1']);

        Notification::assertSentTo(
            $user,
            AccountLogged::class,
            function ($notification, $channels) use ($user, $email) {
                if (!($notification instanceof AccountLogged) || !is_array($channels)) {
                    return false;
                }

                // Ensure the notification can build a MailMessage and that the action URL
                // includes the identifier passed (the signed URL encodes the identifier).
                $mail = $notification->toMail($user);

                // MailMessage exposes actionUrl in common Laravel versions.
                $actionUrl = $mail->actionUrl ?? ($mail->action ?? null);

                if (!is_string($actionUrl)) {
                    return false;
                }

                // The signed URL generated by the service contains the identifier as a query param.
                return strpos($actionUrl, urlencode($email)) !== false || strpos($actionUrl, $email) !== false;
            }
        );
    });
});
